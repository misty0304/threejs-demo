<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - GLTFloader + compressed</title>
		<meta charset="utf-8" />
		<meta
			name="viewport"
			content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
		/>
		<link type="text/css" rel="stylesheet" href="main.css" />
	</head>

	<body>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a>
			- GLTFLoader + compression extensions<br />
			<a
				href="https://sketchfab.com/3d-models/coffeemat-7fb196a40a6e4697aad9ca2f75c8b33d"
				target="_blank"
				rel="noopener"
				>Coffeemat</a
			>
			by
			<a href="https://sketchfab.com/OFFcours1" target="_blank" rel="noopener"
				>Roman Red</a
			>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">
			import * as THREE from "three";

			import { RoomEnvironment } from "three/addons/environments/RoomEnvironment.js";
			import { OrbitControls } from "three/addons/controls/OrbitControls.js";
			import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

			import { KTX2Loader } from "three/addons/loaders/KTX2Loader.js";
			import { MeshoptDecoder } from "three/addons/libs/meshopt_decoder.module.js";

			let camera, scene, renderer;

			init();
			render();

			function init() {
				const container = document.createElement("div");
				document.body.appendChild(container);

				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1;
				container.appendChild(renderer.domElement);

				camera = new THREE.PerspectiveCamera(
					45,
					window.innerWidth / window.innerHeight,
					1,
					2000
				);
				camera.position.set(0, 100, 0);

				const environment = new RoomEnvironment(renderer);
				const pmremGenerator = new THREE.PMREMGenerator(renderer);

				scene = new THREE.Scene();
				scene.background = new THREE.Color(0xbbbbbb);
				scene.environment = pmremGenerator.fromScene(environment).texture;
				environment.dispose();

				const grid = new THREE.GridHelper(500, 10, 0xffffff, 0xffffff);
				grid.material.opacity = 0.5;
				grid.material.depthWrite = false;
				grid.material.transparent = true;
				scene.add(grid);

				const ktx2Loader = new KTX2Loader()
					.setTranscoderPath("jsm/libs/basis/")
					.detectSupport(renderer);

				const loader = new GLTFLoader().setPath("./");
				loader.setKTX2Loader(ktx2Loader);
				loader.setMeshoptDecoder(MeshoptDecoder);
				loader.load("coffeemat.glb", function (gltf) {
					console.log("场景3D模型树结构", scene);
					// coffeemat.glb was produced from the source scene using gltfpack:
					// gltfpack -i coffeemat/scene.gltf -o coffeemat.glb -cc -tc
					// The resulting model uses EXT_meshopt_compression (for geometry) and KHR_texture_basisu (for texture compression using ETC1S/BasisLZ)

					gltf.scene.position.y = 8;

					scene.add(gltf.scene);

					render();
				});

				const controls = new OrbitControls(camera, renderer.domElement);
				controls.addEventListener("change", render); // use if there is no animation loop
				controls.minDistance = 400;
				controls.maxDistance = 1000;
				controls.target.set(10, 90, -16);
				controls.update();

				window.addEventListener("resize", onWindowResize);
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);

				render();
			}

			//

			function render() {
				renderer.render(scene, camera);
			}
			// 初始化射线辅助器
			var raycaster = new THREE.Raycaster();

			// 鼠标控制对象
			var mouse = new THREE.Vector2();

			// 监听鼠标的移动事件
			document.addEventListener("mousemove", onDocumentMouseMove, false);

			// 鼠标移动事件处理函数
			function onDocumentMouseMove(event) {
				console.log("move", 123);
				// 得到鼠标相对于容器的坐标
				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
			}

			// 绑定点击事件
			document.addEventListener("click", onDocumentClick, false);

			// 点击事件处理函数
			function onDocumentClick(event) {
				console.log(1111111, scene);
				// 执行射线检测
				raycaster.setFromCamera(mouse, camera);
				var intersects = raycaster.intersectObjects(scene.children, true);
				console.log("intersects", intersects);

				// 判断是否成功
				if (intersects.length > 0) {
					// 选取第一个物体并对其执行交互
					var object = intersects[0].object;
					interactWithObject(object);
				}
			}

			// 交互函数
			function interactWithObject(object) {
				console.log(1111, object);
				// 判断是否是需要进行交互的模型
				// document.getElementById("shuju").innerHTML = object.name;
			}
		</script>
	</body>
</html>
